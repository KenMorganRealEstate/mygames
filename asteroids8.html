<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MORGAN'S FURY 2112</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts Import -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@900&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
        }

        /* BACKGROUND HANDLING */
        .bg-cover-art {
            background-image: url('https://kenmorganrealestate.github.io/mygames/2112.jpg?v=999');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-color: #000;
        }
        
        .bg-game-over {
            background-image: url('https://kenmorganrealestate.github.io/mygames/chromey.jpg?v=999');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .bg-deep-space {
            background-color: #000000;
        }

        /* VISUAL FX: CRT SCANLINES */
        @keyframes scanline-fade {
            0% { opacity: 1; }
            70% { opacity: 1; } 
            100% { opacity: 0; } 
        }

        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                rgba(18, 16, 16, 0) 50%, 
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            z-index: 90;
            pointer-events: none; 
            opacity: 0; 
        }
        
        .crt-active {
            animation: scanline-fade 4s ease-out forwards;
        }

        /* VISUAL FX: FIRE SPARKS */
        #sparks-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 1;
        }

        .spark {
            position: absolute;
            bottom: -10px;
            background: #fff;
            border-radius: 50%;
            animation: spark-rise linear forwards;
            box-shadow: 0 0 5px #ffaa00, 0 0 10px #ff4400, 0 0 15px #ff0000;
        }

        @keyframes spark-rise {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-100vh) scale(0);
                opacity: 0;
            }
        }

        /* VISUAL FX: ELECTRIC PLASMA BORDER */
        @keyframes electric-pulse {
            0% {
                box-shadow: 0 0 5px #fff, 0 0 10px #bf0000, 0 0 20px #bf0000, inset 0 0 10px #bf0000;
                border-color: #fff;
            }
            25% {
                box-shadow: 0 0 15px #fff, 0 0 30px #ff0000, 0 0 50px #bf0000, inset 0 0 20px #bf0000;
                border-color: #bf0000;
            }
            50% {
                box-shadow: 0 0 5px #fff, 0 0 15px #bf0000, 0 0 10px #bf0000, inset 0 0 5px #bf0000;
                border-color: #ffcccc;
            }
            75% {
                box-shadow: 0 0 25px #fff, 0 0 50px #ff0000, 0 0 70px #bf0000, inset 0 0 30px #bf0000;
                border-color: #bf0000;
            }
            100% {
                box-shadow: 0 0 5px #fff, 0 0 10px #bf0000, 0 0 20px #bf0000, inset 0 0 10px #bf0000;
                border-color: #fff;
            }
        }

        .electric-box {
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #bf0000;
            padding: 25px;
            border-radius: 6px;
            text-align: center;
            max-width: 90%;
            position: relative;
            z-index: 10; 
            animation: electric-pulse 0.15s infinite alternate; 
        }

        /* VISUAL FX: GLITCH TEXT */
        @keyframes glitch-skew {
            0% { transform: skew(0deg); }
            20% { transform: skew(-10deg); }
            40% { transform: skew(10deg); }
            60% { transform: skew(-5deg); }
            80% { transform: skew(5deg); }
            100% { transform: skew(0deg); }
        }
        @keyframes glitch-color {
            0% { text-shadow: 2px 0 #fff, -2px 0 #bf0000; }
            50% { text-shadow: 2px 0 #fff, -2px 0 #bf0000; }
            100% { text-shadow: 2px 0 #fff, -2px 0 #bf0000; }
        }
        
        .glitch-text {
            animation: glitch-skew 1s infinite linear alternate-reverse, 
                       glitch-color 0.2s infinite linear alternate-reverse;
            color: #ffffff;
        }

        /* VISUAL FX: NEON TEXT FLICKER */
        @keyframes neon-flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow: 
                0 0 5px #fff, 
                0 0 10px #bf0000, 
                0 0 20px #bf0000;
                opacity: 1;
            }
            20%, 24%, 55% {       
                text-shadow: none;
                opacity: 0.5;
            }
        }

        .title-font {
            font-family: 'Cinzel Decorative', cursive;
            font-weight: 900;
            color: #bf0000;
            text-shadow: 0 0 5px #fff, 0 0 10px #bf0000, 0 0 20px #bf0000;
            letter-spacing: 2px;
        }
        .title-flicker {
            animation: neon-flicker 4s infinite;
        }
        
        .subtitle-font {
            font-family: 'Cinzel Decorative', cursive;
            color: #e0e0e0;
            letter-spacing: 4px;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        .ui-font {
            font-family: 'Orbitron', sans-serif;
        }

        /* UI LAYERS */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            transition: opacity 0.5s;
        }
        .interactive {
            pointer-events: auto;
        }
        .hidden {
            display: none !important;
        }

        /* COMPONENTS */
        .rush-box {
            background: rgba(0, 0, 0, 0.6); 
            border: 2px solid #bf0000;
            box-shadow: 0 0 20px rgba(191, 0, 0, 0.4);
            padding: 25px;
            border-radius: 4px;
            text-align: center;
            max-width: 90%;
            backdrop-filter: blur(2px);
            z-index: 20;
            position: relative;
        }
        .rush-button {
            background: transparent;
            color: #bf0000;
            border: 2px solid #bf0000;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px #bf0000, inset 0 0 10px #bf0000;
            transition: all 0.3s;
            font-family: 'Orbitron', sans-serif;
            margin-top: 10px;
            text-shadow: 0 0 5px #bf0000;
            display: inline-block;
        }
        .rush-button:hover {
            background: #bf0000;
            color: #000;
            box-shadow: 0 0 30px #bf0000, inset 0 0 30px #bf0000;
            text-shadow: none;
        }
        
        .rush-input {
            background: rgba(0,0,0,0.7);
            border: 1px solid #fff;
            color: #fff;
            padding: 10px;
            font-family: 'Orbitron', sans-serif;
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 10px;
            outline: none;
        }
        .rush-input:focus {
            border-color: #bf0000;
            box-shadow: 0 0 10px #bf0000;
        }

        /* ANIMATIONS */
        .blink-text {
            animation: blinker 1.5s linear infinite;
            color: #ffffff; 
            font-size: 1.2rem;
            margin-top: 30px;
            font-weight: bold;
            text-shadow: 
                0 0 5px #ff4444, 
                0 0 10px #ff4444, 
                0 0 20px #ff4444;
        }
        @keyframes blinker {
            50% { opacity: 0; }
        }

        /* HUD Positioning */
        #score-hud {
            position: absolute;
            top: 20px;
            left: 60px; 
            font-size: 24px;
            color: #bf0000;
            font-weight: bold;
            text-shadow: 0 0 5px #bf0000;
        }
        #lives-hud {
            position: absolute;
            top: 20px;
            right: 30px;
            color: #bf0000;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px #bf0000;
            margin-right: 140px; 
        }
        
        #level-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #bf0000;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px #bf0000;
        }

        #controls-toggle-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 60;
            pointer-events: auto;
        }
        
        #help-toggle-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 60;
            pointer-events: auto;
        }

        .mini-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #bf0000;
            color: #bf0000;
            padding: 8px 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .mini-btn:hover, .mini-btn.active {
            background: #bf0000;
            color: #000;
        }
        
        .help-circle-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #bf0000;
            color: #bf0000;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s;
        }
        .help-circle-btn:hover {
            background: #bf0000;
            color: #000;
            box-shadow: 0 0 10px #bf0000;
        }

        /* DEBRIEF TABLE STYLE */
        .debrief-table {
            width: 100%;
            font-size: 0.85rem;
            color: #ccc;
            margin-bottom: 15px;
        }
        .debrief-table td {
            padding: 2px 5px;
            border: none;
        }
        .debrief-label { color: #bf0000; font-weight: bold; }
        .debrief-val { color: #fff; text-align: right; }
        .section-header {
            border-bottom: 1px solid #bf0000;
            color: #bf0000;
            font-weight: bold;
            margin-top: 10px;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .stat-plus { color: #00ff00; font-size: 0.8em; margin-left: 5px; }
        .stat-minus { color: #ff0000; font-size: 0.8em; margin-left: 5px; }
        
        /* CONTROLS LIST STYLE */
        .control-row {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #333;
            padding: 4px 0;
        }
        .control-key { color: #fff; font-weight: bold; }
        .control-desc { color: #bf0000; }
    </style>
</head>
<body class="bg-cover-art" id="main-body"> 

<div id="crt-layer" class="crt-overlay"></div>

    <div id="audio-wall" class="ui-layer interactive">
        <h1 class="title-font text-4xl mb-4 text-center title-flicker">MORGAN'S FURY 2112</h1>
        <button id="init-audio-btn" class="rush-button">CLICK TO ENGAGE SYSTEMS</button>
    </div>

    <div id="score-hud" class="ui-font hidden">SCORE: <span id="score-val">0</span></div>
    <div id="level-hud" class="ui-font hidden">LEVEL: <span id="level-val">1</span></div>
    <div id="lives-hud" class="ui-font hidden">LIVES: <span id="lives-val">3</span></div>
    
    <div id="controls-toggle-container" class="hidden">
        <button id="toggle-controls-btn" class="mini-btn">SYSTEMS</button>
    </div>
    
    <div id="help-toggle-container" class="hidden">
        <button id="help-btn" class="help-circle-btn">?</button>
    </div>

    <div id="mobile-controls" class="hidden ui-layer">
        <div class="flex justify-between w-full items-end">
            <div class="flex gap-4">
                <button id="btn-left" class="mobile-btn">â†º</button>
                <button id="btn-right" class="mobile-btn">â†»</button>
            </div>
            
            <div class="audio-panel">
                <div class="flex items-center gap-2">
                    <button id="btn-mute" class="mute-btn">M</button>
                    <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.3">
                </div>
                <span class="text-xs text-gray-400 font-bold">AUDIO SYS</span>
            </div>

            <div class="flex gap-4">
                <button id="btn-thrust" class="mobile-btn">ðŸš€</button>
                <button id="btn-fire" class="mobile-btn" style="background: rgba(255, 0, 0, 0.3); border-color: #ff4444;">ðŸ”¥</button>
            </div>
        </div>
    </div>

    <div id="volume-container" class="hidden">
        <p class="text-red-500 font-bold mb-2 ui-font">MASTER VOLUME</p>
        <input type="range" id="volume-slider-kb" min="0" max="1" step="0.1" value="0.3">
    </div>

    <div id="mute-indicator" class="hidden">MUTE ACTIVE</div>

    <!-- FLIGHT MANUAL MODAL (IN GAME) -->
    <div id="help-modal" class="ui-layer interactive hidden z-50" style="background: rgba(0,0,0,0.9);">
        <div class="rush-box w-96">
            <h2 class="title-font text-3xl text-red-500 mb-4">FLIGHT MANUAL</h2>
            
            <div class="text-sm mb-6 text-left">
                <div class="control-row"><span class="control-desc">THRUST:</span> <span class="control-key">DOWN ARROW</span></div>
                <div class="control-row"><span class="control-desc">ROTATE:</span> <span class="control-key">CTRL / ALT</span></div>
                <div class="control-row"><span class="control-desc">FIRE (SEMI-AUTO):</span> <span class="control-key">RIGHT ARROW</span></div>
                <div class="control-row"><span class="control-desc">PAUSE:</span> <span class="control-key">SPACE BAR</span></div>
                <div class="control-row"><span class="control-desc">NEXT SONG:</span> <span class="control-key">UP ARROW</span></div>
                <div class="control-row"><span class="control-desc">MUTE AUDIO:</span> <span class="control-key">'M' KEY</span></div>
                <div class="control-row"><span class="control-desc">VOLUME SLIDER:</span> <span class="control-key">'V' KEY</span></div>
                <div class="control-row border-none mt-2 text-gray-400 italic"><span class="control-desc">NOTE:</span> Use on-screen buttons if mobile.</div>
            </div>

            <button id="close-help-btn" class="rush-button text-sm py-2">RESUME MISSION</button>
        </div>
    </div>

    <div id="start-screen" class="ui-layer interactive hidden">
        <div class="rush-box">
            <h1 class="title-font text-6xl mb-2 title-flicker">MORGAN'S FURY 2112</h1>
            <h2 class="subtitle-font text-2xl mb-6">THE BATTLE FOR SYRINX</h2>
            <p class="text-gray-400 ui-font text-sm mb-6">DEV: KEN MORGAN</p>
            
            <!-- FULL CONTROLS DISPLAY ON START (Replaces simple list) -->
            <div class="mb-6 text-sm w-full md:w-96 mx-auto bg-black/60 p-4 rounded border border-red-900 shadow-lg">
                <h3 class="text-red-500 font-bold border-b border-red-900 mb-2 pb-1">FLIGHT MANUAL</h3>
                <div class="control-row"><span class="control-desc">ROTATE:</span> <span class="control-key">CTRL / ALT</span></div>
                <div class="control-row"><span class="control-desc">THRUST:</span> <span class="control-key">DOWN ARROW</span></div>
                <div class="control-row"><span class="control-desc">FIRE (SEMI-AUTO):</span> <span class="control-key">RIGHT ARROW</span></div>
                <div class="control-row"><span class="control-desc">PAUSE:</span> <span class="control-key">SPACE BAR</span></div>
                <div class="control-row"><span class="control-desc">NEXT SONG:</span> <span class="control-key">UP ARROW</span></div>
                <div class="control-row border-none"><span class="control-desc">SYSTEMS:</span> <span class="control-key">'V' (Vol) | 'M' (Mute) | 'H' (Help)</span></div>
            </div>

            <p class="md:hidden text-red-400 font-bold mb-4">MOBILE: USE ON-SCREEN CONTROLS</p>
            
            <button id="start-btn" class="rush-button">INITIALIZE MISSION</button>

            <!-- High Scores -->
            <div class="mt-6 border-t border-red-900 pt-4">
                <h3 class="text-red-500 font-bold mb-2">HALL OF FAME</h3>
                <table id="highscore-list"></table>
            </div>
            
            <!-- PROMPT FOR RESTORE -->
            <p class="text-xs text-red-400 mt-4 animate-pulse font-bold">RETURNING PILOT? INSERT DATA CARTRIDGE</p>

            <!-- Data Buttons -->
            <div class="mt-2 flex justify-center gap-2 flex-wrap">
                <button id="export-btn-start" class="text-xs border border-gray-600 px-2 py-1 text-gray-400 hover:text-white hover:border-white transition">BACKUP DATA</button>
                <button id="import-btn" class="text-xs border border-gray-600 px-2 py-1 text-gray-400 hover:text-white hover:border-white transition">RESTORE DATA</button>
                <button id="view-career-btn" class="text-xs border border-red-600 text-red-400 px-2 py-1 hover:text-white hover:border-white transition">VIEW CAREER LOG</button>
                <input type="file" id="file-input" class="hidden" accept=".json">
            </div>
        </div>
        
        <div class="blink-text ui-font text-center px-4">
            THE PRIESTS DEMAND SURRENDER.<br>MORGAN HAS ASSUMED CONTROL.
        </div>
    </div>
    
    <!-- Career Stats Modal -->
    <div id="career-modal" class="ui-layer interactive hidden" style="z-index: 80;">
        <div class="rush-box w-96">
            <h3 class="title-font text-3xl mb-4 text-red-500">PILOT ARCHIVES</h3>
            <input type="text" id="career-search-name" class="rush-input w-full mb-4" placeholder="ENTER PILOT NAME">
            <button id="lookup-career-btn" class="rush-button" style="font-size: 1rem; padding: 8px 20px;">ACCESS LOGS</button>
            
            <div id="career-display-area" class="mt-4 hidden text-left text-sm">
                <!-- Populated by JS -->
            </div>
            
            <button id="close-career-btn" class="text-xs text-gray-500 mt-6 hover:text-white">CLOSE ARCHIVES</button>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="ui-layer interactive hidden">
        <div id="sparks-container"></div>

        <div class="electric-box">
            <h1 class="title-font text-5xl mb-4 glitch-text">MISSION FAILED</h1>
            <p class="text-red-500 text-2xl mb-6 ui-font">FINAL SCORE: <span id="final-score">0</span></p>
            
            <!-- Input Phase -->
            <div id="high-score-input-container" class="flex flex-col items-center">
                <p class="text-gray-400 mb-2 ui-font text-sm">IDENTIFY YOURSELF:</p>
                <input type="text" id="player-name" class="rush-input" placeholder="PILOT" maxlength="10" autocomplete="off">
                <button id="save-score-btn" class="rush-button" style="font-size: 1rem; padding: 10px 20px;">SAVE RECORD</button>
            </div>

            <!-- Debrief Phase (Hidden initially) -->
            <div id="debrief-container" class="hidden w-80">
                <div id="debrief-content"></div> 
                
                <div class="mt-4 flex justify-center gap-2">
                    <button id="export-btn-gameover" class="text-xs border border-red-800 bg-red-900/30 px-3 py-2 text-red-300 hover:text-white hover:border-red-500 hover:bg-red-900/60 transition font-bold">BACKUP FLIGHT DATA</button>
                </div>

                <div class="mt-6 flex justify-center gap-4 flex-wrap">
                    <button id="restart-btn" class="rush-button">RE-ENGAGE</button>
                    <button id="return-menu-btn" class="rush-button">RETURN TO MENU</button>
                </div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * CLASSES (DEFINED FIRST)
 */
class FloatingText {
    constructor(x, y, text, color = '#fff') {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 90; 
        this.vy = -1; 
    }
    update() { this.y += this.vy; this.life--; }
    draw() {
        ctx.save();
        ctx.globalAlpha = Math.min(1, this.life / 30);
        ctx.fillStyle = this.color;
        ctx.font = 'bold 24px Orbitron';
        ctx.shadowBlur = 5;
        ctx.shadowColor = this.color;
        ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x, this.y);
        ctx.restore();
    }
}

class Star {
    constructor(mode = 'static') {
        this.mode = mode;
        this.init();
    }
    init() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        if (this.mode === 'warp') {
            this.x = (Math.random() - 0.5) * canvas.width;
            this.y = (Math.random() - 0.5) * canvas.height;
            this.z = Math.random() * canvas.width;
            this.pz = this.z;
        }
        this.size = Math.random() * 2;
        this.alpha = Math.random();
        this.flickerSpeed = 0.02 + Math.random() * 0.05;
    }
    update() {
        if (this.mode === 'warp') {
            this.z = this.z - 20; 
            if (this.z < 1) {
                this.z = canvas.width;
                this.x = (Math.random() - 0.5) * canvas.width;
                this.y = (Math.random() - 0.5) * canvas.height;
                this.pz = this.z;
            }
        } else {
            this.alpha += this.flickerSpeed;
            if (this.alpha >= 1 || this.alpha <= 0.2) this.flickerSpeed *= -1;
        }
    }
    draw() {
        if (this.mode === 'warp') {
            const sx = (this.x / this.z) * (canvas.width/2) + (canvas.width/2);
            const sy = (this.y / this.z) * (canvas.height/2) + (canvas.height/2);
            const r = (1 - this.z / canvas.width) * 4; 
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(sx, sy, Math.max(0, r), 0, Math.PI * 2);
            ctx.fill();
            this.pz = this.z;
        } else {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

class Particle {
    constructor(x, y, color, speed) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = Math.random() * 2 + 1;
        const angle = Math.random() * Math.PI * 2;
        const velocity = Math.random() * speed;
        this.vx = Math.cos(angle) * velocity;
        this.vy = Math.sin(angle) * velocity;
        this.alpha = 1;
        this.decay = 0.015 + Math.random() * 0.02;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.alpha -= this.decay;
    }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, angle, isEnemy = false) {
        this.x = x;
        this.y = y;
        this.radius = 2;
        this.speed = isEnemy ? 8 : 14;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.color = isEnemy ? '#ff0000' : '#ffffff';
        this.isEnemy = isEnemy;
        this.markedForDeletion = false;
        this.lifespan = 55; 
        
        if (isEnemy) {
            if (AudioEngine && typeof AudioEngine.saucerFire === 'function') AudioEngine.saucerFire();
        } else {
            if (AudioEngine && typeof AudioEngine.shoot === 'function') {
                AudioEngine.shoot();
                StatsManager.recordShot();
            }
        }
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.lifespan--;
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height;
        if (this.y > canvas.height) this.y = 0;
        if (this.lifespan <= 0) this.markedForDeletion = true;
    }
    draw() {
        ctx.save();
        ctx.shadowBlur = 5;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class Saucer {
    constructor(type = 'large') {
        this.type = type; 
        if (type === 'small') {
            this.radius = 12;
            this.color = '#ff4444'; 
            this.points = 1000;
            // DYNAMIC DIFFICULTY (ADJUSTED):
            this.accuracy = 0.02 * Math.pow(0.9, level - 1); 
            
            // UPDATED: Speed cap at 0.9x until Level 10
            let speedBase = 0.9;
            let levelBonus = 0;
            if (level >= 10) {
                levelBonus = (level - 10) * 0.1;
            }
            this.speedMult = speedBase + levelBonus;
        } else {
            this.radius = 25;
            this.color = '#ff4444';
            this.points = 500;
            this.accuracy = 0.25 * Math.pow(0.9, level - 1);
            this.speedMult = Math.min(1.3, 1.0 + (level * 0.02));
        }
        this.y = Math.random() * (canvas.height - 100) + 50;
        if (Math.random() < 0.5) {
            this.x = -30;
            this.vx = (3 + Math.random()) * this.speedMult;
        } else {
            this.x = canvas.width + 30;
            this.vx = -(3 + Math.random()) * this.speedMult;
        }
        this.vy = (Math.random() - 0.5) * 2; 
        this.changeDirTimer = 0;
        this.shootTimer = 0;
        this.markedForDeletion = false;
        
        if (AudioEngine && typeof AudioEngine.saucerSpawn === 'function') {
            AudioEngine.saucerSpawn();
        }
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.changeDirTimer++;
        
        // Erratic Movement Logic
        let dirChangeBase = this.type === 'small' ? 40 : 70;
        const dirChangeThresh = Math.max(15, dirChangeBase - (level * 3));
        
        if (this.changeDirTimer > dirChangeThresh) {
            this.vy = (Math.random() - 0.5) * 5; 
            this.changeDirTimer = 0;
        }
        if (this.y < -this.radius) this.y = canvas.height + this.radius;
        if (this.y > canvas.height + this.radius) this.y = -this.radius;
        
        if ((this.vx > 0 && this.x > canvas.width + 50) || (this.vx < 0 && this.x < -50)) {
            this.markedForDeletion = true;
            AudioEngine.stopSaucerSound(); // Stop sound on exit
        }

        this.shootTimer++;
        // ANTI-FARMING (ADJUSTED): 
        let baseRate = this.type === 'small' ? 60 : 100;
        // Slower fire rate increase
        const shootThresh = Math.max(30, baseRate - (level * 2) - (saucersSpawnedCount * 1));
        
        if (this.shootTimer > shootThresh) {
            this.shoot();
            this.shootTimer = 0;
        }
    }
    shoot() {
        if (!player) return;
        let currentAcc = this.accuracy * Math.pow(0.95, saucersSpawnedCount);
        const aimError = (Math.random() - 0.5) * currentAcc;
        const angle = Math.atan2(player.y - this.y, player.x - this.x) + aimError;
        enemyProjectiles.push(new Projectile(this.x, this.y + 5, angle, true));
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        // Vector Saucer
        ctx.beginPath();
        ctx.arc(0, -this.radius*0.25, this.radius*0.5, Math.PI, 0); 
        ctx.moveTo(-this.radius, this.radius*0.25);
        ctx.lineTo(this.radius, this.radius*0.25);
        ctx.lineTo(this.radius*0.75, this.radius*0.6);
        ctx.lineTo(-this.radius*0.75, this.radius*0.6);
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = '#000'; // Black interior
        ctx.fill(); 
        // Windows
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(-this.radius*0.5, this.radius*0.25, 2, 0, Math.PI*2);
        ctx.arc(0, this.radius*0.25, 2, 0, Math.PI*2);
        ctx.arc(this.radius*0.5, this.radius*0.25, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

class Asteroid {
    constructor(x, y, sizeClass) {
        this.sizeClass = sizeClass; 
        this.radius = sizeClass * 12 + 5; 
        this.x = x;
        this.y = y;
        const angle = Math.random() * Math.PI * 2;
        // Slower asteroids
        const baseSpeed = (4 - sizeClass) * 1.0; 
        const randomFlux = Math.random() * (0.2 * level); 
        const speed = baseSpeed + randomFlux;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.rotation = 0;
        this.rotationSpeed = (Math.random() - 0.5) * (0.1 * (4 - sizeClass)); 
        this.color = '#ffffff'; // VISUALS: White Vector Lines
        this.markedForDeletion = false;
        
        this.points = [];
        const vertices = 8 + Math.floor(Math.random() * 6);
        for (let i = 0; i < vertices; i++) {
            const angle = (Math.PI * 2 / vertices) * i;
            const r = this.radius * (0.7 + Math.random() * 0.6);
            this.points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
        }
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += this.rotationSpeed;
        if (this.x < -this.radius) this.x = canvas.width + this.radius;
        if (this.x > canvas.width + this.radius) this.x = -this.radius;
        if (this.y < -this.radius) this.y = canvas.height + this.radius;
        if (this.y > canvas.height + this.radius) this.y = -this.radius;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#fff'; // White glow
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        for (let i = 1; i < this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y);
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = '#000'; // Black fill
        ctx.fill();
        ctx.restore();
    }
}

class Player {
    constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.radius = 15;
        this.angle = -Math.PI / 2; 
        this.vx = 0;
        this.vy = 0;
        this.acceleration = 0.15; 
        this.friction = 0.99; 
        this.rotationSpeed = 0.08;
        this.color = '#ffffff'; // VISUALS: White ship
        this.visible = true; 
        this.iFrames = 120; 
        this.thrusting = false;
    }
    update() {
        if (!this.visible) {
            AudioEngine.stopThrust();
            return; 
        }
        if (keys.Control) this.angle -= this.rotationSpeed;
        if (keys.Alt) this.angle += this.rotationSpeed;
        
        this.thrusting = false;
        if (keys.ArrowDown) { 
            this.thrusting = true;
            this.vx += Math.cos(this.angle) * this.acceleration;
            this.vy += Math.sin(this.angle) * this.acceleration;
            AudioEngine.startThrust();
            if (Math.random() > 0.5) {
                const backAngle = this.angle + Math.PI + (Math.random() - 0.5) * 0.5;
                particles.push(new Particle(this.x + Math.cos(backAngle)*this.radius, this.y + Math.sin(backAngle)*this.radius, '#ffaa00', 3)); 
            }
        } else {
            AudioEngine.stopThrust();
        }
        this.vx *= this.friction;
        this.vy *= this.friction;
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > 10) { this.vx = (this.vx/speed)*10; this.vy = (this.vy/speed)*10; }
        this.x += this.vx;
        this.y += this.vy;
        if (this.x < -this.radius) this.x = canvas.width + this.radius;
        if (this.x > canvas.width + this.radius) this.x = -this.radius;
        if (this.y < -this.radius) this.y = canvas.height + this.radius;
        if (this.y > canvas.height + this.radius) this.y = -this.radius;
        if (this.iFrames > 0) this.iFrames--;
    }
    shoot() {
        if (!this.visible) return; 
        this.vx -= Math.cos(this.angle) * 0.2;
        this.vy -= Math.sin(this.angle) * 0.2;
        const tipX = this.x + Math.cos(this.angle) * (this.radius + 5);
        const tipY = this.y + Math.sin(this.angle) * (this.radius + 5);
        projectiles.push(new Projectile(tipX, tipY, this.angle, false));
    }
    draw() {
        if (!this.visible) return; 
        if (this.iFrames > 0 && Math.floor(Date.now() / 100) % 2 === 0) return; 
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#fff';
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.fillStyle = '#000';
        // Vector Ship
        ctx.beginPath();
        ctx.moveTo(20, 0); 
        ctx.lineTo(-15, 12); 
        ctx.lineTo(-10, 0); 
        ctx.lineTo(-15, -12); 
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        if (this.thrusting) {
            ctx.fillStyle = '#ffaa00';
            ctx.shadowColor = '#ffaa00';
            ctx.beginPath();
            ctx.moveTo(-12, 6);
            ctx.lineTo(-25 - Math.random() * 10, 0);
            ctx.lineTo(-12, -6);
            ctx.fill();
        }
        ctx.restore();
    }
    die() {
        if (this.iFrames > 0 || !this.visible) return;
        this.visible = false;
        AudioEngine.stopThrust();
        lives--;
        livesElement.innerText = lives;
        addShake(20, 15);
        AudioEngine.playShipExplosion();
        for(let i=0; i<50; i++) particles.push(new Particle(this.x, this.y, '#fff', 8));
        if (lives < 0) gameOver();
        else respawnTimer = 120; 
    }
    resetPosition() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.vx = 0;
        this.vy = 0;
        this.angle = -Math.PI / 2;
        this.visible = true;
        this.iFrames = 180; 
        // Clear spawn area
        asteroids.forEach(a => {
            if (getDistance(this.x, this.y, a.x, a.y) < 150) a.x += (a.x < this.x ? -200 : 200);
        });
    }
}

/**
 * VISUAL FX MANAGER
 */
function triggerCRT() {
    const crt = document.getElementById('crt-layer');
    crt.classList.remove('crt-active');
    void crt.offsetWidth; 
    crt.classList.add('crt-active');
}

let sparkInterval;
let crackleInterval;

function createSpark() {
    const container = document.getElementById('sparks-container');
    if (!container) return;
    const spark = document.createElement('div');
    spark.classList.add('spark');
    const size = Math.random() * 6 + 3 + 'px';
    spark.style.width = size;
    spark.style.height = size;
    spark.style.left = Math.random() * 100 + '%';
    const colors = ['#ffdd55', '#ffaa00', '#ff4400', '#ff0000'];
    spark.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
    const duration = Math.random() * 2 + 2 + 's';
    spark.style.animationDuration = duration;
    container.appendChild(spark);
    setTimeout(() => { spark.remove(); }, 4000);
}
function startSparks() {
    if(sparkInterval) clearInterval(sparkInterval);
    sparkInterval = setInterval(createSpark, 60); 
}
function stopSparks() {
    if(sparkInterval) clearInterval(sparkInterval);
    const container = document.getElementById('sparks-container');
    if(container) container.innerHTML = '';
}

// Audio Crackle Logic
function startAudioCrackle() {
    if(crackleInterval) clearInterval(crackleInterval);
    // Random crackle every 200ms to 2s
    crackleInterval = setInterval(() => {
        if (Math.random() > 0.7) AudioEngine.playSpark();
    }, 200); 
}

function stopAudioCrackle() {
    if(crackleInterval) clearInterval(crackleInterval);
}

/**
 * MANAGERS
 */
const StatsManager = {
    session: {
        shotsFired: 0,
        shotsHit: 0,
        asteroidsDestroyed: 0,
        saucersDestroyed: 0,
        saucersSmallDestroyed: 0,
        startTime: 0,
        endTime: 0
    },
    careerData: {}, 
    initSession() {
        this.session = {
            shotsFired: 0,
            shotsHit: 0,
            asteroidsDestroyed: 0,
            saucersDestroyed: 0,
            saucersSmallDestroyed: 0,
            startTime: Date.now(),
            endTime: 0
        };
        const stored = localStorage.getItem('morgans_fury_2112_career');
        this.careerData = stored ? JSON.parse(stored) : {};
    },
    recordShot() { this.session.shotsFired++; },
    recordHit() { this.session.shotsHit++; },
    recordAsteroidKill() { this.session.asteroidsDestroyed++; },
    recordSaucerKill(type) {
        this.session.saucersDestroyed++;
        if(type === 'small') this.session.saucersSmallDestroyed++;
    },
    endSession() { this.session.endTime = Date.now(); },
    
    getCareerStats(name) {
        const stored = localStorage.getItem('morgans_fury_2112_career');
        const allData = stored ? JSON.parse(stored) : {};
        return allData[name] || null;
    },
    
    saveToCareer(name) {
        if(!this.careerData[name]) {
            this.careerData[name] = {
                totalShots: 0, totalHits: 0, asteroids: 0,
                saucers: 0, smallSaucers: 0, playTime: 0, sorties: 0
            };
        }
        const pilot = this.careerData[name];
        const oldAcc = pilot.totalShots > 0 ? (pilot.totalHits / pilot.totalShots) * 100 : 0;
        pilot.totalShots += this.session.shotsFired;
        pilot.totalHits += this.session.shotsHit;
        pilot.asteroids += this.session.asteroidsDestroyed;
        pilot.saucers += this.session.saucersDestroyed;
        pilot.smallSaucers += this.session.saucersSmallDestroyed;
        pilot.playTime += (this.session.endTime - this.session.startTime);
        pilot.sorties++;
        const newAcc = pilot.totalShots > 0 ? (pilot.totalHits / pilot.totalShots) * 100 : 0;
        const deltaAcc = newAcc - oldAcc;
        localStorage.setItem('morgans_fury_2112_career', JSON.stringify(this.careerData));
        return { pilot, deltaAcc };
    },
    getFormattedTime(ms) {
        const sec = Math.floor((ms / 1000) % 60);
        const min = Math.floor((ms / (1000 * 60)) % 60);
        const hrs = Math.floor((ms / (1000 * 60 * 60)));
        return `${hrs}h ${min}m ${sec}s`;
    }
};

const MusicManager = {
    menuTrack: new Audio('https://kenmorganrealestate.github.io/mygames/overture.mp3'),
    playlistUrls: [
        'https://kenmorganrealestate.github.io/mygames/limelight.mp3',
        'https://kenmorganrealestate.github.io/mygames/bangkok.mp3',
        'https://kenmorganrealestate.github.io/mygames/anthem.mp3',
        'https://kenmorganrealestate.github.io/mygames/bestican.mp3',
        'https://kenmorganrealestate.github.io/mygames/somethingfornothing.mp3',
        'https://kenmorganrealestate.github.io/mygames/stickitout.mp3',
        'https://kenmorganrealestate.github.io/mygames/syrnix.mp3',
        'https://kenmorganrealestate.github.io/mygames/twilightzone.mp3'
    ],
    outroTrack: new Audio('https://kenmorganrealestate.github.io/mygames/outro2112.mp3'),
    currentTrack: null,
    isPlayingGameMusic: false,
    volume: 0.3, 
    muted: false,
    init() {
        this.menuTrack.loop = true;
        this.updateVolume();
        this.menuTrack.load();
        this.outroTrack.load();
    },
    setVolume(val) {
        this.volume = parseFloat(val);
        this.updateVolume();
    },
    toggleMute() {
        this.muted = !this.muted;
        this.updateVolume();
        return this.muted;
    },
    updateVolume() {
        const effectiveVol = this.muted ? 0 : this.volume;
        if (this.menuTrack) this.menuTrack.volume = effectiveVol;
        if (this.currentTrack) this.currentTrack.volume = effectiveVol;
        if (this.outroTrack) this.outroTrack.volume = effectiveVol;
    },
    playMenu() {
        this.stopGameMusic();
        this.stopOutro();
        this.updateVolume(); 
        if (this.menuTrack.paused) {
            const playPromise = this.menuTrack.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => console.warn("Menu Music Auto-play blocked:", error));
            }
        }
    },
    stopMenu() {
        this.menuTrack.pause();
        this.menuTrack.currentTime = 0;
    },
    playRandomGameTrack() {
        this.stopMenu();
        this.stopOutro();
        this.isPlayingGameMusic = true;
        const url = this.playlistUrls[Math.floor(Math.random() * this.playlistUrls.length)];
        if (this.currentTrack) this.currentTrack.pause();
        this.currentTrack = new Audio(url);
        this.updateVolume(); 
        this.currentTrack.addEventListener('ended', () => {
            if (this.isPlayingGameMusic) this.playRandomGameTrack();
        });
        this.currentTrack.addEventListener('error', (e) => {
             if (this.isPlayingGameMusic) setTimeout(() => this.playRandomGameTrack(), 2000);
        });
        const playPromise = this.currentTrack.play();
        if (playPromise !== undefined) playPromise.catch(e => console.warn("Game track play interrupted:", e));
    },
    stopGameMusic() {
        this.isPlayingGameMusic = false;
        if (this.currentTrack) {
            this.currentTrack.pause();
            this.currentTrack = null;
        }
    },
    playOutro() {
        this.stopGameMusic();
        this.stopMenu();
        this.updateVolume();
        this.outroTrack.currentTime = 0;
        this.outroTrack.play().catch(e => console.warn("Outro play error:", e));
    },
    stopOutro() {
        this.outroTrack.pause();
        this.outroTrack.currentTime = 0;
    }
};

const AudioEngine = {
    ctx: null,
    enabled: true,
    noiseBuffer: null,
    explosionBuffer: null, 
    saucerPlaylist: [
        'https://kenmorganrealestate.github.io/mygames/2112Ringtone.mp3'
    ],
    saucerEntry: new Audio(), 
    shipExplosion: new Audio('https://kenmorganrealestate.github.io/mygames/explosion.mp3'),
    rocketSound: new Audio('https://kenmorganrealestate.github.io/mygames/rocket.mp3'),
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.createNoiseBuffer();
            this.loadExplosionSound(); 
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
        this.shipExplosion.load();
        this.rocketSound.loop = true;
        this.rocketSound.volume = 0.5; 
    },
    createNoiseBuffer() {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * 2; 
        this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = this.noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    },
    loadExplosionSound() {
        if (!this.ctx) return;
        fetch('https://kenmorganrealestate.github.io/mygames/explosion.mp3')
            .then(response => response.arrayBuffer())
            .then(arrayBuffer => this.ctx.decodeAudioData(arrayBuffer))
            .then(audioBuffer => { this.explosionBuffer = audioBuffer; })
            .catch(e => console.warn("Explosion sound load error:", e));
    },
    
    // Short burst of static for "Crackle" effect
    playSpark() {
        if (!this.enabled || !this.ctx || MusicManager.muted) return;
        const t = this.ctx.currentTime;
        const noise = this.ctx.createBufferSource();
        noise.buffer = this.noiseBuffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 1000;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1); 
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
        noise.stop(t + 0.1);
    },
    
    // Level Up Sound
    playLevelUp() {
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        // C
        const osc1 = this.ctx.createOscillator();
        const g1 = this.ctx.createGain();
        osc1.type = 'square'; osc1.frequency.value = 523.25;
        osc1.connect(g1); g1.connect(this.ctx.destination);
        g1.gain.setValueAtTime(0.1, t); g1.gain.linearRampToValueAtTime(0, t+0.1);
        osc1.start(t); osc1.stop(t+0.1);
        // E
        const osc2 = this.ctx.createOscillator();
        const g2 = this.ctx.createGain();
        osc2.type = 'square'; osc2.frequency.value = 659.25; 
        osc2.connect(g2); g2.connect(this.ctx.destination);
        g2.gain.setValueAtTime(0.1, t+0.1); g2.gain.linearRampToValueAtTime(0, t+0.2);
        osc2.start(t+0.1); osc2.stop(t+0.2);
        // G
        const osc3 = this.ctx.createOscillator();
        const g3 = this.ctx.createGain();
        osc3.type = 'square'; osc3.frequency.value = 783.99; 
        osc3.connect(g3); g3.connect(this.ctx.destination);
        g3.gain.setValueAtTime(0.1, t+0.2); g3.gain.linearRampToValueAtTime(0, t+0.4);
        osc3.start(t+0.2); osc3.stop(t+0.4);
    },

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.enabled || !this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    },
    shoot() {
        if (!this.enabled || !this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.type = 'sawtooth'; 
        osc.frequency.setValueAtTime(880, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(110, this.ctx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
        osc.start(); osc.stop(this.ctx.currentTime + 0.2);
    },
    startThrust() {
        if (!this.enabled) return; // Removed MusicManager.muted check
        if (this.rocketSound.paused) {
            this.rocketSound.play().catch(e => {});
        }
    },
    stopThrust() {
        if (!this.rocketSound.paused) {
            this.rocketSound.pause();
            this.rocketSound.currentTime = 0;
        }
    },
    explode(volume = 0.4) {
        if (!this.enabled || !this.ctx) return;
        if (this.explosionBuffer) {
            const source = this.ctx.createBufferSource();
            source.buffer = this.explosionBuffer;
            const gain = this.ctx.createGain();
            gain.gain.value = volume; 
            source.connect(gain); gain.connect(this.ctx.destination);
            source.start(0);
        } else {
            const t = this.ctx.currentTime;
            const noise = this.ctx.createBufferSource();
            noise.buffer = this.noiseBuffer;
            const noiseFilter = this.ctx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(800, t);
            noiseFilter.frequency.linearRampToValueAtTime(100, t + 0.3);
            const noiseGain = this.ctx.createGain();
            noiseGain.gain.setValueAtTime(volume, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
            noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(this.ctx.destination);
            noise.start(); noise.stop(t + 0.4);
        }
    },
    playShipExplosion() { if (!this.enabled) return; this.explode(0.8); },
    extraLife() {
        if (!this.enabled || !this.ctx) return;
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'square'; osc.connect(gain); gain.connect(this.ctx.destination);
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.setValueAtTime(554, now + 0.1);
        osc.frequency.setValueAtTime(659, now + 0.2);
        osc.frequency.setValueAtTime(880, now + 0.3);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.5);
        osc.start(); osc.stop(now + 0.5);
    },
    saucerFire() { if (!this.enabled || !this.ctx) return; this.playTone(800, 'sine', 0.1, 0.1); },
    saucerSpawn() {
        if (!this.enabled || !this.ctx) return;
        const url = this.saucerPlaylist[Math.floor(Math.random() * this.saucerPlaylist.length)];
        this.saucerEntry.src = url;
        this.saucerEntry.volume = 0.6;
        this.saucerEntry.currentTime = 0;
        this.saucerEntry.play().catch(e => console.warn("Saucer MP3 error:", e));
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const lfo = this.ctx.createOscillator();
        lfo.frequency.value = 12; lfo.connect(gain.gain);
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(800, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(400, this.ctx.currentTime + 1.0);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); lfo.start();
        osc.stop(this.ctx.currentTime + 1.0); lfo.stop(this.ctx.currentTime + 1.0);
    },
    stopSaucerSound() {
        if (this.saucerEntry) { this.saucerEntry.pause(); this.saucerEntry.currentTime = 0; }
    }
};

/** * GAME VARIABLES */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState = 'INIT_WAIT'; 
let isPaused = false;
let score = 0;
let lives = 3; 
let nextLifeThreshold = 10000; 
let respawnTimer = 0; 
let level = 1;
let animationId;
const STORAGE_KEY = 'morgans_fury_2112_scores';

const keys = { 
    w: false, a: false, s: false, d: false, ' ': false, 
    ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false,
    Control: false, Alt: false, v: false, m: false
};
const mouse = { x: 0, y: 0, down: false };

let player;
let projectiles = [];
let enemyProjectiles = [];
let asteroids = [];
let floatingTexts = []; 
let saucer = null;
let saucerTimer = 0; 
let saucersSpawnedCount = 0; 
let particles = [];
let stars = [];

const scoreElement = document.getElementById('score-val');
const levelElement = document.getElementById('level-val'); 
const finalScoreElement = document.getElementById('final-score');
const livesElement = document.getElementById('lives-val'); 
const bodyElement = document.getElementById('main-body');

let shakeDuration = 0;
let shakeMagnitude = 0;

// --- Event Listeners ---
window.addEventListener('resize', resizeCanvas);

document.getElementById('init-audio-btn').addEventListener('click', () => {
    MusicManager.init();
    MusicManager.playMenu();
    AudioEngine.init();
    triggerCRT(); 
    document.getElementById('audio-wall').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
    if(window.innerWidth < 768) {
        document.getElementById('mobile-controls').classList.remove('hidden');
    }
    gameState = 'START';
    resizeCanvas();
    initStars('warp'); 
    animate();
});

const volumeSlider = document.getElementById('volume-slider');
const volumeSliderKb = document.getElementById('volume-slider-kb');
const muteBtn = document.getElementById('btn-mute');

function syncVolume(e) {
    const val = e.target.value;
    volumeSlider.value = val;
    volumeSliderKb.value = val;
    MusicManager.setVolume(val);
}
volumeSlider.addEventListener('input', syncVolume);
volumeSliderKb.addEventListener('input', syncVolume);

muteBtn.addEventListener('click', () => {
    const isMuted = MusicManager.toggleMute();
    muteBtn.classList.toggle('active', isMuted);
});

document.getElementById('toggle-controls-btn').addEventListener('click', () => {
    const controls = document.getElementById('mobile-controls');
    controls.classList.toggle('hidden');
});

// Help Toggle Logic
document.getElementById('help-btn').addEventListener('click', () => {
    const modal = document.getElementById('help-modal');
    const start = document.getElementById('start-screen');
    
    if (gameState === 'PLAYING') {
        isPaused = true;
        modal.classList.remove('hidden');
    } else if (gameState === 'START') {
        start.classList.add('hidden');
        modal.classList.remove('hidden');
    }
});

document.getElementById('close-help-btn').addEventListener('click', () => {
    const modal = document.getElementById('help-modal');
    const start = document.getElementById('start-screen');
    
    modal.classList.add('hidden');
    if (gameState === 'PLAYING') {
        isPaused = false;
    } else if (gameState === 'START') {
        start.classList.remove('hidden');
    }
});

const btnLeft = document.getElementById('btn-left');
const btnRight = document.getElementById('btn-right');
const btnThrust = document.getElementById('btn-thrust');
const btnFire = document.getElementById('btn-fire');

function handleTouchStart(key) {
    keys[key] = true;
    if (key === 'ArrowRight' && gameState === 'PLAYING' && !isPaused && player) {
        player.shoot(); // Fire only on touch start
    }
}
function handleTouchEnd(key) { keys[key] = false; }

btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouchStart('Control'); });
btnLeft.addEventListener('touchend', (e) => { e.preventDefault(); handleTouchEnd('Control'); });
btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouchStart('Alt'); });
btnRight.addEventListener('touchend', (e) => { e.preventDefault(); handleTouchEnd('Alt'); });
btnThrust.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouchStart('ArrowDown'); });
btnThrust.addEventListener('touchend', (e) => { e.preventDefault(); handleTouchEnd('ArrowDown'); });
btnFire.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouchStart('ArrowRight'); });
btnFire.addEventListener('touchend', (e) => { e.preventDefault(); handleTouchEnd('ArrowRight'); });

btnLeft.addEventListener('mousedown', (e) => { e.preventDefault(); handleTouchStart('Control'); });
btnLeft.addEventListener('mouseup', (e) => { e.preventDefault(); handleTouchEnd('Control'); });
btnRight.addEventListener('mousedown', (e) => { e.preventDefault(); handleTouchStart('Alt'); });
btnRight.addEventListener('mouseup', (e) => { e.preventDefault(); handleTouchEnd('Alt'); });
btnThrust.addEventListener('mousedown', (e) => { e.preventDefault(); handleTouchStart('ArrowDown'); });
btnThrust.addEventListener('mouseup', (e) => { e.preventDefault(); handleTouchEnd('ArrowDown'); });
btnFire.addEventListener('mousedown', (e) => { e.preventDefault(); handleTouchStart('ArrowRight'); });
btnFire.addEventListener('mouseup', (e) => { e.preventDefault(); handleTouchEnd('ArrowRight'); });

window.addEventListener('keydown', (e) => {
    // Prevent repeated firing (Semi-Auto)
    if (e.repeat && e.key === 'ArrowRight') return;
    
    keys[e.key] = true;
    if (['ArrowDown', 'ArrowRight', 'ArrowLeft', 'ArrowUp', ' ', 'Alt'].includes(e.key)) e.preventDefault();
    
    if (e.key === ' ' && gameState === 'PLAYING') isPaused = !isPaused;
    if (e.key.toLowerCase() === 'v') document.getElementById('volume-container').classList.toggle('hidden');
    if (e.key.toLowerCase() === 'm') {
        const isMuted = MusicManager.toggleMute();
        muteBtn.classList.toggle('active', isMuted);
        document.getElementById('mute-indicator').classList.toggle('hidden', !isMuted);
    }
    if (e.key === 'ArrowUp' && gameState === 'PLAYING') MusicManager.playRandomGameTrack();
    
    // Secret Help Shortcut
    if (e.key.toLowerCase() === 'h') document.getElementById('help-btn').click();
    
    // Single Shot Trigger
    if ((e.key === 'ArrowRight') && gameState === 'PLAYING' && !isPaused && player) player.shoot();
});
window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
    if (e.key === 'Alt') e.preventDefault();
});

canvas.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
// Mouse Click Shooting (Semi-Auto)
canvas.addEventListener('mousedown', () => {
    mouse.down = true;
    if(gameState === 'PLAYING' && player) player.shoot();
});
canvas.addEventListener('mouseup', () => mouse.down = false);
canvas.addEventListener('touchstart', (e) => {
    if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
        e.preventDefault(); 
        const touch = e.touches[0];
        mouse.x = touch.clientX;
        mouse.y = touch.clientY;
        mouse.down = true;
        if(gameState === 'PLAYING' && player) player.shoot();
    }
}, {passive: false});
canvas.addEventListener('touchmove', (e) => {
    if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
        e.preventDefault(); 
        const touch = e.touches[0];
        mouse.x = touch.clientX;
        mouse.y = touch.clientY;
    }
}, {passive: false});
canvas.addEventListener('touchend', (e) => { 
    if(e.target.tagName !== 'BUTTON' && e.target.tagName !== 'INPUT') {
        e.preventDefault(); mouse.down = false; 
    }
});

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', startGame);
document.getElementById('return-menu-btn').addEventListener('click', returnToMenu); 
document.getElementById('export-btn-start').addEventListener('click', exportData);
document.getElementById('export-btn-gameover').addEventListener('click', exportData);
document.getElementById('save-score-btn').addEventListener('click', saveHighScore);
document.getElementById('import-btn').addEventListener('click', () => document.getElementById('file-input').click());
document.getElementById('file-input').addEventListener('change', importData);
// NEW: View Career Modal Logic
document.getElementById('view-career-btn').addEventListener('click', () => {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('career-modal').classList.remove('hidden');
});
document.getElementById('close-career-btn').addEventListener('click', () => {
    document.getElementById('career-modal').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
});
document.getElementById('lookup-career-btn').addEventListener('click', () => {
    const name = document.getElementById('career-search-name').value.toUpperCase();
    const stats = StatsManager.getCareerStats(name);
    const display = document.getElementById('career-display-area');
    
    if (stats) {
        display.innerHTML = `
            <div class="section-header">CAREER LOG: ${name}</div>
            <table class="debrief-table">
                <tr><td class="debrief-label">SORTIES FLOWN:</td><td class="debrief-val">${stats.sorties}</td></tr>
                <tr><td class="debrief-label">TOTAL SHOTS:</td><td class="debrief-val">${stats.totalShots}</td></tr>
                <tr><td class="debrief-label">ACCURACY:</td><td class="debrief-val">${stats.totalShots > 0 ? Math.round((stats.totalHits / stats.totalShots)*100) : 0}%</td></tr>
                <tr><td class="debrief-label">ASTEROIDS:</td><td class="debrief-val">${stats.asteroids}</td></tr>
                <tr><td class="debrief-label">SAUCERS:</td><td class="debrief-val">${stats.saucers} (${stats.smallSaucers} ACE)</td></tr>
                <tr><td class="debrief-label">FLIGHT TIME:</td><td class="debrief-val">${StatsManager.getFormattedTime(stats.playTime)}</td></tr>
            </table>
        `;
    } else {
        display.innerHTML = `<p class="text-red-500 text-center mt-4">PILOT NOT FOUND IN ARCHIVES</p>`;
    }
    display.classList.remove('hidden');
});

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if (gameState === 'START') initStars('warp'); 
    else if (gameState === 'PLAYING') initStars('static'); 
}

function getHighScores() {
    const data = localStorage.getItem(STORAGE_KEY);
    return data ? JSON.parse(data) : [];
}
function renderHighScoreTable(tableId) {
    const scores = getHighScores();
    const list = document.getElementById(tableId);
    if (!list) return;
    list.innerHTML = '';
    if (scores.length === 0) {
        list.innerHTML = '<tr><td colspan="2" class="text-gray-500">No Data Found</td></tr>';
        return;
    }
    scores.slice(0, 5).forEach((s, index) => {
        const row = document.createElement('tr');
        const rankClass = index === 0 ? 'rank-1' : index === 1 ? 'rank-2' : '';
        row.innerHTML = `<td class="text-left ${rankClass}">${index + 1}. ${s.name}</td><td class="text-right ${rankClass}">${s.score}</td>`;
        list.appendChild(row);
    });
}
function updateHighScoreUI() {
    renderHighScoreTable('highscore-list');
    renderHighScoreTable('highscore-list-gameover');
}
function saveHighScore() {
    const nameInput = document.getElementById('player-name');
    const name = nameInput.value.toUpperCase() || 'PILOT';
    const scores = getHighScores();
    scores.push({ name: name, score: score, date: new Date().toISOString() });
    scores.sort((a, b) => b.score - a.score);
    const topScores = scores.slice(0, 10);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(topScores));
    StatsManager.endSession(); 
    const { pilot, deltaAcc } = StatsManager.saveToCareer(name);
    const deltaStr = deltaAcc >= 0 ? `(+${deltaAcc.toFixed(1)}%)` : `(${deltaAcc.toFixed(1)}%)`;
    const deltaClass = deltaAcc >= 0 ? 'stat-plus' : 'stat-minus';
    const debriefDiv = document.getElementById('debrief-content');
    if(debriefDiv) {
        debriefDiv.innerHTML = `
            <div class="text-center mb-2">
                <div class="section-header">MISSION REPORT [SESSION]</div>
                <table class="debrief-table">
                    <tr><td class="debrief-label">SHOTS FIRED:</td><td class="debrief-val">${StatsManager.session.shotsFired}</td></tr>
                    <tr><td class="debrief-label">IMPACTS:</td><td class="debrief-val">${StatsManager.session.shotsHit}</td></tr>
                    <tr><td class="debrief-label">ACCURACY:</td><td class="debrief-val">${Math.round((StatsManager.session.shotsHit / Math.max(1, StatsManager.session.shotsFired))*100)}%</td></tr>
                    <tr><td class="debrief-label">ASTEROIDS:</td><td class="debrief-val">${StatsManager.session.asteroidsDestroyed}</td></tr>
                    <tr><td class="debrief-label">SAUCERS (ACE):</td><td class="debrief-val">${StatsManager.session.saucersDestroyed} (${StatsManager.session.saucersSmallDestroyed})</td></tr>
                </table>
                <div class="section-header">CAREER LOG [${name}]</div>
                <table class="debrief-table">
                    <tr><td class="debrief-label">TOTAL SORTIES:</td><td class="debrief-val">${pilot.sorties}</td></tr>
                    <tr><td class="debrief-label">TOTAL KILLS:</td><td class="debrief-val">${pilot.asteroids + pilot.saucers}</td></tr>
                    <tr><td class="debrief-label">LIFETIME ACC:</td><td class="debrief-val">${pilot.totalShots > 0 ? Math.round((pilot.totalHits / pilot.totalShots)*100) : 0}% <span class="${deltaClass}">${deltaStr}</span></td></tr>
                </table>
            </div>
        `;
    }
    document.getElementById('high-score-input-container').classList.add('hidden');
    document.getElementById('debrief-container').classList.remove('hidden'); 
    document.getElementById('restart-btn').classList.remove('hidden');
    document.getElementById('return-menu-btn').classList.remove('hidden'); 
    updateHighScoreUI();
}
function exportData() {
    const scores = getHighScores();
    const career = JSON.parse(localStorage.getItem('morgans_fury_2112_career') || '{}');
    const exportObj = { highScores: scores, careerStats: career };
    const dataStr = JSON.stringify(exportObj, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `morgans_fury_flight_data_${new Date().toISOString().slice(0,10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}
function importData(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            if (Array.isArray(data)) {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } else if (data.highScores && data.careerStats) {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data.highScores));
                localStorage.setItem('morgans_fury_2112_career', JSON.stringify(data.careerStats));
            }
            updateHighScoreUI();
            const stored = localStorage.getItem('morgans_fury_2112_career');
            StatsManager.careerData = stored ? JSON.parse(stored) : {};
            alert('Flight Data Restored.');
        } catch (err) { alert('Read Error.'); }
        event.target.value = ''; 
    };
    reader.readAsText(file);
}

function randomRange(min, max) { return Math.random() * (max - min) + min; }
function getDistance(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }
function addShake(duration, magnitude) { shakeDuration = duration; shakeMagnitude = magnitude; }
function checkExtraLife() {
    if (score >= nextLifeThreshold) {
        lives++;
        livesElement.innerText = lives;
        nextLifeThreshold += 10000;
        floatingTexts.push(new FloatingText(canvas.width/2, canvas.height/2 - 50, "REINFORCEMENTS ARRIVED!", "#00ff00"));
        AudioEngine.extraLife();
        for(let i=0; i<20; i++) particles.push(new Particle(player.x, player.y, '#00ff00', 5));
    }
}
function initStars(mode = 'static') {
    stars = [];
    const count = mode === 'warp' ? 300 : 100;
    for (let i = 0; i < count; i++) stars.push(new Star(mode));
}
function startWave() {
    // Updated quantity logic: slower ramp up
    const count = 3 + Math.floor(level * 0.5); 
    for(let i = 0; i < count; i++) {
        let x, y, safe = false;
        while(!safe) {
            x = Math.random() * canvas.width;
            y = Math.random() * canvas.height;
            if (player && getDistance(x, y, player.x, player.y) > 200) safe = true;
            else if (!player) safe = true; 
        }
        asteroids.push(new Asteroid(x, y, 3));
    }
}
function startGame() {
    resizeCanvas();
    MusicManager.playRandomGameTrack(); 
    
    // Reset Stats
    StatsManager.initSession();

    bodyElement.classList.remove('bg-cover-art');
    bodyElement.classList.remove('bg-game-over'); 
    bodyElement.classList.add('bg-deep-space');
    if (window.innerWidth > 768) {
        document.getElementById('mobile-controls').classList.add('hidden');
    } else {
        document.getElementById('mobile-controls').classList.remove('hidden');
    }
    document.getElementById('controls-toggle-container').classList.remove('hidden');
    document.getElementById('help-toggle-container').classList.remove('hidden'); 
    gameState = 'PLAYING';
    isPaused = false;
    score = 0;
    lives = 3; 
    nextLifeThreshold = 10000;
    livesElement.innerText = lives;
    level = 1;
    scoreElement.innerText = score;
    levelElement.innerText = level; // Reset Level Display
    projectiles = [];
    enemyProjectiles = [];
    asteroids = [];
    particles = [];
    floatingTexts = [];
    respawnTimer = 0;
    saucer = null;
    saucerTimer = randomRange(500, 1000); 
    saucersSpawnedCount = 0; 
    player = new Player(); 
    initStars('static'); 
    startWave();
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    
    // Reset UI state for next game over
    document.getElementById('high-score-input-container').classList.remove('hidden');
    document.getElementById('debrief-container').classList.add('hidden'); 
    document.getElementById('restart-btn').classList.add('hidden');
    document.getElementById('return-menu-btn').classList.add('hidden'); 
    document.getElementById('player-name').value = '';
    
    document.getElementById('score-hud').classList.remove('hidden');
    document.getElementById('lives-hud').classList.remove('hidden'); 
    document.getElementById('level-hud').classList.remove('hidden');
}
function gameOver() {
    gameState = 'GAMEOVER';
    MusicManager.stopGameMusic();
    AudioEngine.stopSaucerSound(); 
    AudioEngine.stopThrust(); 
    startAudioCrackle(); 
    MusicManager.playOutro(); 
    triggerCRT(); 
    startSparks();
    bodyElement.classList.remove('bg-deep-space');
    bodyElement.classList.add('bg-game-over'); 
    document.getElementById('mobile-controls').classList.add('hidden');
    document.getElementById('controls-toggle-container').classList.add('hidden');
    document.getElementById('help-toggle-container').classList.add('hidden');
    finalScoreElement.innerText = score;
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('score-hud').classList.add('hidden');
    document.getElementById('lives-hud').classList.add('hidden');
    document.getElementById('level-hud').classList.add('hidden');
    updateHighScoreUI();
}
function returnToMenu() {
    gameState = 'START';
    stopSparks(); 
    MusicManager.stopGameMusic();
    MusicManager.stopOutro();     
    AudioEngine.stopSaucerSound(); 
    AudioEngine.stopThrust(); 
    stopAudioCrackle(); 
    MusicManager.playMenu(); 
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
    document.getElementById('mobile-controls').classList.add('hidden');
    document.getElementById('career-modal').classList.add('hidden');
    updateHighScoreUI();
    bodyElement.classList.remove('bg-game-over');
    bodyElement.classList.add('bg-cover-art'); 
    bodyElement.classList.remove('bg-deep-space'); 
    initStars('warp'); 
    resizeCanvas();
}
function animate() {
    animationId = requestAnimationFrame(animate);
    if (gameState === 'PLAYING' || gameState === 'START' || gameState === 'GAMEOVER') {
        if (bodyElement.classList.contains('bg-deep-space')) {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        if (gameState === 'PLAYING' || gameState === 'START') {
            stars.forEach(star => { star.update(); star.draw(); });
        }
    }
    if (isPaused || gameState === 'START' || gameState === 'GAMEOVER') return;

    if (shakeDuration > 0) {
        const dx = (Math.random() - 0.5) * shakeMagnitude;
        const dy = (Math.random() - 0.5) * shakeMagnitude;
        ctx.save();
        ctx.translate(dx, dy);
        shakeDuration--;
    }
    if (gameState === 'PLAYING') {
        if (player && !player.visible && lives >= 0) {
            respawnTimer--;
            if (respawnTimer <= 0) player.resetPosition();
        }
        if (asteroids.length === 0 && !saucer) { 
            level++;
            levelElement.innerText = level; // Update UI
            score += 1000;
            checkExtraLife();
            scoreElement.innerText = score;
            floatingTexts.push(new FloatingText(player ? player.x : canvas.width/2, player ? player.y - 20 : canvas.height/2, "SECTOR CLEARED", "#ffffff"));
            addShake(10, 5);
            AudioEngine.playLevelUp(); // Play new sound
            startWave();
        }
        if (!saucer) {
            saucerTimer--;
            if (saucerTimer <= 0) {
                let difficultyFactor = (level * 0.05) + (saucersSpawnedCount * 0.02);
                let smallChance = Math.min(0.9, Math.max(0, (level - 3) * 0.1 + (saucersSpawnedCount * 0.01)));
                if (level < 4 && saucersSpawnedCount < 5) smallChance = 0.1; 
                let type = (Math.random() < smallChance) ? 'small' : 'large';
                saucer = new Saucer(type);
                saucersSpawnedCount++;
                saucerTimer = randomRange(1000 - (difficultyFactor * 100), 2000 - (difficultyFactor * 100)); 
            }
        } else {
            saucer.update();
            saucer.draw();
            if (player && player.visible && getDistance(player.x, player.y, saucer.x, saucer.y) < player.radius + saucer.radius) {
                player.die();
                saucer.markedForDeletion = true;
                AudioEngine.stopSaucerSound(); 
            }
            if (saucer.markedForDeletion) saucer = null;
        }
        if (player) { player.update(); player.draw(); }
        
        projectiles.forEach((p, i) => {
            p.update(); p.draw();
            if (p.markedForDeletion) projectiles.splice(i, 1);
        });
        enemyProjectiles.forEach((p, i) => {
            p.update(); p.draw();
            if (p.markedForDeletion) enemyProjectiles.splice(i, 1);
            if (player && player.visible && getDistance(p.x, p.y, player.x, player.y) < player.radius + 5) {
                player.die();
                p.markedForDeletion = true;
            }
        });
        particles.forEach((p, i) => {
            p.update(); p.draw();
            if (p.alpha <= 0) particles.splice(i, 1);
        });
        floatingTexts.forEach((f, i) => {
            f.update(); f.draw();
            if (f.life <= 0) floatingTexts.splice(i, 1);
        });
        asteroids.forEach((a, i) => {
            a.update(); a.draw();
            if (player && player.visible && getDistance(player.x, player.y, a.x, a.y) < player.radius + a.radius) {
                player.die();
                a.markedForDeletion = true;
            }
            projectiles.forEach(p => {
                if (getDistance(p.x, p.y, a.x, a.y) < a.radius + p.radius) {
                    a.markedForDeletion = true;
                    p.markedForDeletion = true;
                    const pts = (4 - a.sizeClass) * 50;
                    
                    // STATS: Record Hit
                    StatsManager.recordHit();
                    StatsManager.recordAsteroidKill();

                    score += pts;
                    checkExtraLife();
                    scoreElement.innerText = score;
                    floatingTexts.push(new FloatingText(a.x, a.y, pts, '#fff'));
                    AudioEngine.explode();
                    addShake(2, 2);
                    for(let k=0; k<8*a.sizeClass; k++) particles.push(new Particle(a.x, a.y, '#fff', 4));
                    if (a.sizeClass > 1) {
                        for(let k=0; k<2; k++) {
                            const newAst = new Asteroid(a.x, a.y, a.sizeClass - 1);
                            newAst.vx = (Math.random() - 0.5) * 4;
                            newAst.vy = (Math.random() - 0.5) * 4;
                            asteroids.push(newAst);
                        }
                    }
                }
            });
            if (saucer) {
                 projectiles.forEach(p => {
                    if (getDistance(p.x, p.y, saucer.x, saucer.y) < saucer.radius + p.radius) {
                        saucer.markedForDeletion = true;
                        p.markedForDeletion = true;
                        
                        // STATS: Record Hit & Kill
                        StatsManager.recordHit();
                        StatsManager.recordSaucerKill(saucer.type);

                        const pts = saucer.points;
                        score += pts;
                        checkExtraLife();
                        scoreElement.innerText = score;
                        floatingTexts.push(new FloatingText(saucer.x, saucer.y, pts, '#ff4444'));
                        AudioEngine.explode();
                        AudioEngine.stopSaucerSound(); 
                        addShake(8, 8);
                        for(let k=0; k<20; k++) particles.push(new Particle(saucer.x, saucer.y, '#ff4444', 6));
                    }
                 });
            }
            if (a.markedForDeletion) asteroids.splice(i, 1);
        });
    }
    if (shakeDuration > 0 || shakeDuration === 0) ctx.restore();
}

updateHighScoreUI();
initStars();
resizeCanvas();
</script>
</body>
</html>