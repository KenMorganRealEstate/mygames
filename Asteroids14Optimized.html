<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MORGAN'S FURY 2112</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@900&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #000;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; user-select: none; -webkit-user-select: none;
            overscroll-behavior: none;
        }
        canvas { display: block; }

        /* --- VISUALS --- */
        .bg-cover-art {
            background-image: url('https://kenmorganrealestate.github.io/mygames/2112.jpg?v=999');
            background-size: cover; background-position: center; background-repeat: no-repeat; background-color: #000;
        }
        .bg-game-over {
            background-image: url('https://kenmorganrealestate.github.io/mygames/chromey.jpg?v=999');
            background-size: cover; background-position: center; background-repeat: no-repeat;
        }
        .bg-deep-space { background-color: #000000; }

        /* --- UI --- */
        .title-font { font-family: 'Cinzel Decorative', cursive; font-weight: 900; color: #bf0000; text-shadow: 0 0 5px #fff, 0 0 10px #bf0000; }
        .ui-font { font-family: 'Orbitron', sans-serif; }
        
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10;
        }
        .interactive { pointer-events: auto; }
        .hidden { display: none !important; }

        .rush-box {
            background: rgba(0, 0, 0, 0.85); border: 2px solid #bf0000; box-shadow: 0 0 20px rgba(191, 0, 0, 0.4);
            padding: 25px; border-radius: 4px; text-align: center; max-width: 90%; position: relative; z-index: 20;
        }
        .rush-button {
            background: transparent; color: #bf0000; border: 2px solid #bf0000; padding: 15px 30px;
            font-size: 1.2rem; font-weight: bold; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 10px #bf0000; transition: all 0.2s; font-family: 'Orbitron', sans-serif; margin-top: 10px;
        }
        .rush-button:active { background: #bf0000; color: #000; }
        .rush-input { background: rgba(0,0,0,0.7); border: 1px solid #fff; color: #fff; padding: 10px; text-align: center; font-size: 1.2rem; outline: none; }

        /* --- DRAGGABLE BUTTONS --- */
        .drag-btn {
            position: absolute;
            width: 75px; height: 75px;
            border-radius: 50%;
            background: rgba(60, 60, 60, 0.4);
            border: 2px solid #fff;
            color: #fff;
            font-size: 1.8rem;
            display: flex; justify-content: center; align-items: center;
            user-select: none; -webkit-user-select: none;
            touch-action: none;
            backdrop-filter: blur(2px);
            z-index: 9999; 
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .drag-btn.pressed {
            background-color: rgba(255, 0, 0, 0.8) !important;
            border-color: #ff0000 !important;
            transform: scale(0.95);
            box-shadow: 0 0 20px #ff0000;
        }

        /* Edit Mode Styles */
        .edit-mode .drag-btn {
            border-color: #00ff00; border-style: dashed; background: rgba(0, 255, 0, 0.2);
            animation: pulse-border 1s infinite;
        }
        @keyframes pulse-border { 0% { border-color: #00ff00; } 50% { border-color: #fff; } 100% { border-color: #00ff00; } }

        /* --- SWITCHES --- */
        .toggle-row { display: flex; justify-content: space-between; width: 100%; margin-bottom: 12px; align-items: center; }
        .switch { position: relative; display: inline-block; width: 50px; height: 24px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #333; transition: .4s; transform: skew(-10deg); border: 1px solid #555; }
        .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 3px; bottom: 3px; background-color: #888; transition: .4s; }
        input:checked + .slider { background-color: #000; border-color: #bf0000; }
        input:checked + .slider:before { transform: translateX(26px); background-color: #bf0000; }

        /* HUD */
        #score-hud, #lives-hud, #level-hud { position: absolute; top: 20px; color: #bf0000; font-size: 20px; font-weight: bold; text-shadow: 0 0 5px #bf0000; pointer-events: none; z-index: 50; }
        #score-hud { left: 20px; }
        #lives-hud { right: 20px; }
        #level-hud { left: 50%; transform: translateX(-50%); }

        /* FX: CRT & Sparks */
        #crt-layer { pointer-events: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 90; background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.25) 50%); background-size: 100% 4px; opacity: 0; }
        .crt-active { animation: scanline-fade 4s ease-out forwards; }
        @keyframes scanline-fade { 0% { opacity: 1; } 100% { opacity: 0; } }
        
        #sparks-container { position: absolute; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 1; }
        .spark { position: absolute; width: 5px; height: 5px; background: orange; border-radius: 50%; animation: floatUp 2s linear forwards; }
        @keyframes floatUp { to { transform: translateY(-100vh); opacity: 0; } }
    </style>
</head>
<body class="bg-cover-art" id="main-body"> 

    <div id="crt-layer" class="crt-overlay"></div>
    <div id="sparks-container"></div>

    <div id="audio-wall" class="ui-layer interactive" style="z-index: 100;">
        <h1 class="title-font text-4xl mb-4 text-center">MORGAN'S FURY 2112</h1>
        <button id="init-audio-btn" class="rush-button">ENGAGE SYSTEMS</button>
    </div>

    <div id="score-hud" class="ui-font hidden">SCORE: <span id="score-val">0</span></div>
    <div id="level-hud" class="ui-font hidden">LEVEL: <span id="level-val">1</span></div>
    <div id="lives-hud" class="ui-font hidden">LIVES: <span id="lives-val">3</span></div>

    <div id="touch-interface" class="hidden" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; z-index: 9000; pointer-events: none;">
        <div id="btn-left" class="drag-btn" style="bottom: 120px; left: 20px;">
            <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
        </div>
        <div id="btn-right" class="drag-btn" style="bottom: 120px; left: 110px;">
            <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><path d="M21 12a9 9 0 1 1-9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></svg>
        </div>
        <div id="btn-thrust" class="drag-btn" style="bottom: 30px; left: 65px; width: 85px; height: 85px; border-color: #fff;">ðŸš€</div>
        <div id="btn-fire" class="drag-btn" style="bottom: 40px; right: 30px; width: 90px; height: 90px; border-color: #ff4444; color: #ff4444;">ðŸ”¥</div>
        <div id="btn-hyperspace" class="drag-btn" style="bottom: 150px; right: 40px; border-color: #a0a0ff; color: #a0a0ff;">âš¡</div>
        <div id="btn-pause" class="drag-btn" style="top: 20px; left: 20px; width: 50px; height: 50px; font-size: 1rem;">II</div>
        <div id="btn-music" class="drag-btn" style="top: 20px; right: 20px; width: 50px; height: 50px; font-size: 1rem;">â™«</div>
    </div>

    <div id="start-screen" class="ui-layer interactive hidden" style="z-index: 50;">
        <div class="rush-box w-96">
            <h1 class="title-font text-4xl mb-2">MORGAN'S FURY 2112</h1>
            <p class="text-gray-400 ui-font text-xs mb-6">DEV: KEN MORGAN</p>
            
            <div class="bg-black/80 p-4 rounded border border-gray-700 mb-6 w-full text-left">
                <h3 class="text-red-500 font-bold mb-3 border-b border-gray-700 pb-1 text-sm text-center">CONTROLS SETUP</h3>
                <div class="toggle-row">
                    <span class="text-xs text-gray-300">ENABLE TOUCH BUTTONS</span>
                    <label class="switch"><input type="checkbox" id="touch-toggle"><span class="slider"></span></label>
                </div>
                <div class="toggle-row">
                    <span class="text-xs text-yellow-500 font-bold">CUSTOMIZE LAYOUT (DRAG)</span>
                    <label class="switch"><input type="checkbox" id="edit-toggle"><span class="slider"></span></label>
                </div>
                <p class="text-xs text-gray-500 italic text-center mt-2">*Turn Customize OFF to Play</p>
            </div>
            
            <button id="start-btn" class="rush-button w-full">INITIALIZE MISSION</button>

            <div class="mt-4 border-t border-red-900 pt-2">
                <h3 class="text-red-500 font-bold text-xs">HALL OF FAME</h3>
                <table id="highscore-list" class="w-full text-xs text-gray-400"></table>
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="ui-layer interactive hidden" style="z-index: 50;">
        <div class="rush-box">
            <h1 class="title-font text-5xl mb-4 text-white">MISSION FAILED</h1>
            <p class="text-red-500 text-2xl mb-6 ui-font">SCORE: <span id="final-score">0</span></p>
            <input type="text" id="player-name" class="rush-input" placeholder="PILOT NAME" maxlength="10">
            <br>
            <button id="save-score-btn" class="rush-button text-sm mt-4">SAVE RECORD</button>
            <div class="mt-4 flex gap-2 justify-center">
                <button id="restart-btn" class="rush-button text-sm">RETRY</button>
                <button id="return-menu-btn" class="rush-button text-sm">MENU</button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * MORGAN'S FURY 2112 - FINAL ADJUSTED PHYSICS
 */

// --- VARIABLES ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const STORAGE_KEY = 'morgans_fury_scores';

let gameState = 'INIT_WAIT';
let isPaused = false;
let isEditMode = false;

let score = 0;
let lives = 3;
let level = 1;
let saucersSpawnedCount = 0;
let saucer = null;
let saucerTimer = 0;
let nextLifeThreshold = 10000;
let shakeDuration = 0;
let shakeMagnitude = 0;

const keys = { 
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, 
    Control: false, Alt: false, Shift: false, ' ': false 
};

let player;
let projectiles = [];
let enemyProjectiles = [];
let asteroids = [];
let particles = [];
let stars = [];
let floatingTexts = [];

// --- CLASSES ---

class FloatingText {
    constructor(x, y, text, color = '#fff') {
        this.x = x; this.y = y; this.text = text; this.color = color;
        this.life = 90; this.vy = -1;
    }
    update() { this.y += this.vy; this.life--; }
    draw() {
        ctx.save(); ctx.globalAlpha = Math.min(1, this.life / 30);
        ctx.fillStyle = this.color; ctx.font = 'bold 24px Orbitron';
        ctx.textAlign = 'center'; ctx.fillText(this.text, this.x, this.y); ctx.restore();
    }
}

class Star {
    constructor(mode = 'static') {
        this.mode = mode; this.layer = Math.floor(Math.random() * 3); this.init();
    }
    init() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        if (this.mode === 'warp') {
            this.x = (Math.random() - 0.5) * canvas.width;
            this.y = (Math.random() - 0.5) * canvas.height;
            this.z = Math.random() * canvas.width;
            this.pz = this.z;
        }
        if (this.layer === 0) { this.size = 1; this.alphaBase = 0.3; }
        else if (this.layer === 1) { this.size = 1.5; this.alphaBase = 0.6; }
        else { this.size = 2; this.alphaBase = 1.0; }
        this.alpha = this.alphaBase;
    }
    update() {
        if (this.mode === 'warp') {
            let speed = 20; if (this.layer === 0) speed = 10; if (this.layer === 1) speed = 15;
            this.z = this.z - speed;
            if (this.z < 1) {
                this.z = canvas.width; this.x = (Math.random() - 0.5) * canvas.width; this.y = (Math.random() - 0.5) * canvas.height;
            }
        }
    }
    draw() {
        if (this.mode === 'warp') {
            const sx = (this.x / this.z) * (canvas.width/2) + (canvas.width/2);
            const sy = (this.y / this.z) * (canvas.height/2) + (canvas.height/2);
            const r = (1 - this.z / canvas.width) * (this.size * 2);
            ctx.fillStyle = `rgba(255,255,255,${this.layer === 0 ? 0.5 : 1})`;
            ctx.beginPath(); ctx.arc(sx, sy, Math.max(0, r), 0, Math.PI * 2); ctx.fill();
        } else {
            ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha})`;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        }
    }
}

class Projectile {
    constructor(x, y, angle, isEnemy = false) {
        this.x = x; this.y = y; this.radius = 2;
        this.speed = isEnemy ? 8 : 14;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.color = isEnemy ? '#ff0000' : '#ffffff';
        this.isEnemy = isEnemy;
        this.markedForDeletion = false;
        
        // FIXED LIFESPAN: Player shots fade after 45 frames (short range), Enemies 100
        this.lifespan = isEnemy ? 100 : 100; 
        
        if (isEnemy) { if (AudioEngine && typeof AudioEngine.saucerFire === 'function') AudioEngine.saucerFire(); } 
        else { if (AudioEngine && typeof AudioEngine.shoot === 'function') AudioEngine.shoot(); }
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.lifespan--;
        if (this.x < 0) this.x = canvas.width; if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height; if (this.y > canvas.height) this.y = 0;
        
        // Kill bullet if lifespan ends
        if (this.lifespan <= 0) this.markedForDeletion = true;
    }
    draw() {
        ctx.save(); ctx.shadowBlur = 5; ctx.shadowColor = this.color;
        // Fade out as they die
        ctx.globalAlpha = Math.min(1, this.lifespan / 10);
        ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore();
    }
}

class Saucer {
    constructor(type = 'large') {
        this.type = type; 
        if (type === 'small') {
            this.radius = 12; this.color = '#ff4444'; this.points = 1000; this.accuracy = 0.02 * Math.pow(0.9, level - 1);
            let speedBase = 0.9; let levelBonus = (level >= 10) ? (level - 10) * 0.1 : 0;
            this.speedMult = speedBase + levelBonus;
        } else {
            this.radius = 25; this.color = '#ff4444'; this.points = 500; this.accuracy = 0.25 * Math.pow(0.9, level - 1);
            this.speedMult = Math.min(1.3, 1.0 + (level * 0.02));
        }
        this.y = Math.random() * (canvas.height - 100) + 50;
        if (Math.random() < 0.5) { this.x = -30; this.vx = (3 + Math.random()) * this.speedMult; } 
        else { this.x = canvas.width + 30; this.vx = -(3 + Math.random()) * this.speedMult; }
        this.vy = (Math.random() - 0.5) * 2; 
        this.changeDirTimer = 0; this.shootTimer = 0; this.markedForDeletion = false;
        AudioEngine.saucerSpawn();
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.changeDirTimer++;
        if (this.changeDirTimer > 70) { this.vy = (Math.random() - 0.5) * 5; this.changeDirTimer = 0; }
        if (this.y < -this.radius) this.y = canvas.height + this.radius;
        if (this.y > canvas.height + this.radius) this.y = -this.radius;
        if ((this.vx > 0 && this.x > canvas.width + 50) || (this.vx < 0 && this.x < -50)) {
            this.markedForDeletion = true; AudioEngine.stopSaucerSound();
        }
        this.shootTimer++;
        if (this.shootTimer > 100) { this.shoot(); this.shootTimer = 0; }
    }
    shoot() {
        if (!player) return;
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        enemyProjectiles.push(new Projectile(this.x, this.y + 5, angle, true));
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y);
        ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.strokeStyle = this.color; ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -this.radius*0.25, this.radius*0.5, Math.PI, 0); 
        ctx.moveTo(-this.radius, this.radius*0.25); ctx.lineTo(this.radius, this.radius*0.25);
        ctx.lineTo(this.radius*0.75, this.radius*0.6); ctx.lineTo(-this.radius*0.75, this.radius*0.6);
        ctx.closePath(); ctx.stroke();
        ctx.fillStyle = '#000'; ctx.fill(); 
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(-this.radius*0.5, this.radius*0.25, 2, 0, Math.PI*2);
        ctx.arc(0, this.radius*0.25, 2, 0, Math.PI*2); ctx.arc(this.radius*0.5, this.radius*0.25, 2, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }
}

class Asteroid {
    constructor(x, y, sizeClass) {
        this.sizeClass = sizeClass; this.radius = sizeClass * 12 + 5;
        this.x = x; this.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = (4 - sizeClass) * 1.0;
        this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed;
        this.rotation = 0; this.rotationSpeed = (Math.random() - 0.5) * 0.1;
        this.color = '#ffffff'; this.markedForDeletion = false;
        this.points = [];
        const vertices = 8 + Math.floor(Math.random() * 6);
        for (let i = 0; i < vertices; i++) {
            const angle = (Math.PI * 2 / vertices) * i;
            const r = this.radius * (0.7 + Math.random() * 0.6);
            this.points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
        }
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.rotation += this.rotationSpeed;
        if (this.x < -this.radius) this.x = canvas.width + this.radius;
        if (this.x > canvas.width + this.radius) this.x = -this.radius;
        if (this.y < -this.radius) this.y = canvas.height + this.radius;
        if (this.y > canvas.height + this.radius) this.y = -this.radius;
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation);
        ctx.strokeStyle = this.color; ctx.lineWidth = 2; ctx.shadowBlur = 8; ctx.shadowColor = '#fff'; 
        ctx.beginPath(); ctx.moveTo(this.points[0].x, this.points[0].y);
        for (let i = 1; i < this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y);
        ctx.closePath(); ctx.stroke(); ctx.fillStyle = '#000'; ctx.fill(); ctx.restore();
    }
}

class Player {
    constructor() {
        this.x = canvas.width / 2; this.y = canvas.height / 2;
        this.radius = 15; this.angle = -Math.PI / 2; 
        this.vx = 0; this.vy = 0;
        this.acceleration = 0.15; this.friction = 0.99; this.rotationSpeed = 0.08;
        this.visible = true; this.iFrames = 120; this.thrusting = false;
    }
    hyperspace() {
        if (!this.visible) return;
        this.x = Math.random() * canvas.width; this.y = Math.random() * canvas.height;
        this.vx = 0; this.vy = 0;
        AudioEngine.playWarp();
        const body = document.getElementById('main-body');
        body.style.backgroundColor = '#fff'; setTimeout(() => { body.style.backgroundColor = '#000'; }, 100);
    }
    update() {
        if (!this.visible) { AudioEngine.stopThrust(); return; }
        if (keys.Control) this.angle -= this.rotationSpeed;
        if (keys.Alt) this.angle += this.rotationSpeed;
        this.thrusting = false;
        if (keys.ArrowDown) { 
            this.thrusting = true;
            this.vx += Math.cos(this.angle) * this.acceleration;
            this.vy += Math.sin(this.angle) * this.acceleration;
            AudioEngine.startThrust();
            if (Math.random() > 0.5) {
                const backAngle = this.angle + Math.PI + (Math.random() - 0.5) * 0.5;
                particles.push(new Particle(this.x + Math.cos(backAngle)*this.radius, this.y + Math.sin(backAngle)*this.radius, '#ffaa00', 3)); 
            }
        } else {
            AudioEngine.stopThrust();
        }
        if (keys.Shift) { keys.Shift = false; this.hyperspace(); }
        this.vx *= this.friction; this.vy *= this.friction;
        this.x += this.vx; this.y += this.vy;
        if (this.x < -this.radius) this.x = canvas.width + this.radius;
        if (this.x > canvas.width + this.radius) this.x = -this.radius;
        if (this.y < -this.radius) this.y = canvas.height + this.radius;
        if (this.y > canvas.height + this.radius) this.y = -this.radius;
        if (this.iFrames > 0) this.iFrames--;
    }
    shoot() {
        if (!this.visible) return; 
        this.vx -= Math.cos(this.angle) * 0.2; this.vy -= Math.sin(this.angle) * 0.2;
        const tipX = this.x + Math.cos(this.angle) * (this.radius + 5);
        const tipY = this.y + Math.sin(this.angle) * (this.radius + 5);
        projectiles.push(new Projectile(tipX, tipY, this.angle, false));
    }
    draw() {
        if (!this.visible) return; 
        if (this.iFrames > 0 && Math.floor(Date.now() / 100) % 2 === 0) return; 
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        ctx.shadowBlur = 10; ctx.shadowColor = '#fff'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.moveTo(20, 0); ctx.lineTo(-15, 12); ctx.lineTo(-10, 0); ctx.lineTo(-15, -12); ctx.closePath();
        ctx.fill(); ctx.stroke();
        if (this.thrusting) {
            ctx.fillStyle = '#ffaa00'; ctx.shadowColor = '#ffaa00';
            ctx.beginPath(); ctx.moveTo(-12, 6); ctx.lineTo(-25 - Math.random() * 10, 0); ctx.lineTo(-12, -6); ctx.fill();
        }
        ctx.restore();
    }
    die() {
        if (this.iFrames > 0 || !this.visible) return;
        this.visible = false; AudioEngine.stopThrust();
        lives--; document.getElementById('lives-val').innerText = lives;
        shakeDuration = 20; shakeMagnitude = 15;
        AudioEngine.playShipExplosion();
        for(let i=0; i<50; i++) particles.push(new Particle(this.x, this.y, '#fff', 8));
        if (lives < 0) gameOver(); else setTimeout(() => player.resetPosition(), 2000);
    }
    resetPosition() {
        this.x = canvas.width / 2; this.y = canvas.height / 2;
        this.vx = 0; this.vy = 0; this.angle = -Math.PI / 2;
        this.visible = true; this.iFrames = 180; 
        asteroids.forEach(a => { if (Math.hypot(this.x-a.x, this.y-a.y) < 150) a.x += (a.x < this.x ? -200 : 200); });
    }
}

class Particle {
    constructor(x, y, color, speed) {
        this.x = x; this.y = y; this.color = color;
        const angle = Math.random() * Math.PI * 2; const velocity = Math.random() * speed;
        this.vx = Math.cos(angle) * velocity; this.vy = Math.sin(angle) * velocity;
        this.alpha = 1;
        // FIXED EXHAUST: Fade faster (0.04) so they don't linger forever
        this.decay = 0.02 + Math.random() * 0.03;
    }
    update() { this.x += this.vx; this.y += this.vy; this.alpha -= this.decay; }
    draw() {
        ctx.save(); ctx.globalAlpha = Math.max(0, this.alpha); ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, Math.random()*2+1, 0, Math.PI * 2); ctx.fill(); ctx.restore();
    }
}

// --- AUDIO ---
const MusicManager = {
    menuTrack: new Audio('https://kenmorganrealestate.github.io/mygames/overture.mp3'),
    playlistUrls: [
        'https://kenmorganrealestate.github.io/mygames/limelight.mp3',
        'https://kenmorganrealestate.github.io/mygames/somethingfornothing.mp3',
        'https://kenmorganrealestate.github.io/mygames/stickitout.mp3',
        'https://kenmorganrealestate.github.io/mygames/syrnix.mp3',
        'https://kenmorganrealestate.github.io/mygames/twilightzone.mp3'
    ],
    outroTrack: new Audio('https://kenmorganrealestate.github.io/mygames/outro2112.mp3'),
    currentTrack: null,
    isPlayingGameMusic: false,
    init() { this.menuTrack.loop = true; this.menuTrack.load(); },
    playMenu() { this.stopGameMusic(); this.stopOutro(); this.menuTrack.play().catch(e=>{}); },
    playRandomGameTrack() {
        this.menuTrack.pause(); this.outroTrack.pause();
        const url = this.playlistUrls[Math.floor(Math.random()*this.playlistUrls.length)];
        if(this.currentTrack) this.currentTrack.pause();
        this.currentTrack = new Audio(url);
        this.currentTrack.volume = 0.3;
        this.currentTrack.play().catch(e=>{});
        this.currentTrack.onended = () => this.playRandomGameTrack();
        floatingTexts.push(new FloatingText(canvas.width/2, 60, "NOW PLAYING", "#00ff00"));
    },
    stopGameMusic() { if(this.currentTrack) this.currentTrack.pause(); },
    playOutro() { this.stopGameMusic(); this.menuTrack.pause(); this.outroTrack.play().catch(e=>{}); },
    stopOutro() { this.outroTrack.pause(); this.outroTrack.currentTime=0; }
};

const AudioEngine = {
    ctx: null, noiseBuffer: null, explosionBuffer: null,
    rocketSound: new Audio('https://kenmorganrealestate.github.io/mygames/rocket.mp3'),
    saucerEntry: new Audio('https://kenmorganrealestate.github.io/mygames/2112Ringtone.mp3'),
    init() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.rocketSound.loop = true; this.rocketSound.volume = 0.5;
        this.saucerEntry.loop = true; this.saucerEntry.volume = 0.6;
        this.createNoiseBuffer(); this.loadExplosion();
    },
    createNoiseBuffer() {
        const bufferSize = this.ctx.sampleRate * 2;
        this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = this.noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    },
    loadExplosion() {
        fetch('https://kenmorganrealestate.github.io/mygames/explosion.mp3')
            .then(r=>r.arrayBuffer()).then(b=>this.ctx.decodeAudioData(b)).then(a=>{this.explosionBuffer=a;});
    },
    playShipExplosion() {
        if(this.explosionBuffer) {
            const s = this.ctx.createBufferSource(); s.buffer = this.explosionBuffer;
            const g = this.ctx.createGain(); g.gain.value=0.8;
            s.connect(g); g.connect(this.ctx.destination); s.start(0);
        }
    },
    explode() { this.playShipExplosion(); },
    playWarp() {
        const t = this.ctx.currentTime;
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.connect(g); g.connect(this.ctx.destination);
        o.frequency.setValueAtTime(200, t); o.frequency.exponentialRampToValueAtTime(2000, t+0.1);
        g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.5);
        o.start(); o.stop(t+0.5);
    },
    shoot() {
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.connect(g); g.connect(this.ctx.destination); o.type='sawtooth';
        o.frequency.setValueAtTime(880, this.ctx.currentTime); o.frequency.exponentialRampToValueAtTime(110, this.ctx.currentTime+0.2);
        g.gain.setValueAtTime(0.1, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime+0.2);
        o.start(); o.stop(this.ctx.currentTime+0.2);
    },
    startThrust() { if(this.rocketSound.paused) this.rocketSound.play().catch(e=>{}); },
    stopThrust() { if(!this.rocketSound.paused) { this.rocketSound.pause(); this.rocketSound.currentTime=0; } },
    saucerSpawn() { this.saucerEntry.play().catch(e=>{}); },
    stopSaucerSound() { this.saucerEntry.pause(); this.saucerEntry.currentTime=0; },
    saucerFire() { 
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.type='sine'; o.frequency.value=800; o.connect(g); g.connect(this.ctx.destination);
        g.gain.value=0.1; o.start(); o.stop(this.ctx.currentTime+0.1);
    }
};

// --- TOUCH LOGIC ---
const touchInterface = document.getElementById('touch-interface');
const touchToggle = document.getElementById('touch-toggle');
const editToggle = document.getElementById('edit-toggle');
const dragButtons = document.querySelectorAll('.drag-btn');

function setupDrag(el) {
    let offsetX, offsetY;
    el.addEventListener('pointerdown', (e) => {
        if(!isEditMode) return;
        el.setPointerCapture(e.pointerId);
        const rect = el.getBoundingClientRect();
        offsetX = e.clientX - rect.left; offsetY = e.clientY - rect.top;
        el.dataset.dragging = "true";
    });
    el.addEventListener('pointermove', (e) => {
        if(!isEditMode || el.dataset.dragging !== "true") return;
        el.style.left = (e.clientX - offsetX) + 'px';
        el.style.top = (e.clientY - offsetY) + 'px';
        el.style.bottom = 'auto'; el.style.right = 'auto';
    });
    el.addEventListener('pointerup', (e) => { el.dataset.dragging = "false"; el.releasePointerCapture(e.pointerId); });
}

function setupGameAction(id, keyMap) {
    const el = document.getElementById(id);
    const press = (e) => {
        if(isEditMode) return; e.preventDefault(); el.classList.add('pressed'); 
        if(keyMap === 'SHOOT') { if(player && !isPaused) player.shoot(); } 
        else if (keyMap === 'HYPERSPACE') { if(player && !isPaused) player.hyperspace(); } 
        else if (keyMap === 'PAUSE') { isPaused = !isPaused; } 
        else if (keyMap === 'MUSIC') { MusicManager.playRandomGameTrack(); } 
        else { keys[keyMap] = true; } 
    };
    const release = (e) => {
        if(isEditMode) return; e.preventDefault(); el.classList.remove('pressed');
        if(['SHOOT','HYPERSPACE','PAUSE','MUSIC'].indexOf(keyMap) === -1) keys[keyMap] = false;
    };
    el.addEventListener('pointerdown', press);
    el.addEventListener('pointerup', release); el.addEventListener('pointerleave', release); el.addEventListener('pointercancel', release);
}

dragButtons.forEach(btn => setupDrag(btn));
setupGameAction('btn-left', 'Control');
setupGameAction('btn-right', 'Alt');
setupGameAction('btn-thrust', 'ArrowDown');
setupGameAction('btn-fire', 'SHOOT');
setupGameAction('btn-hyperspace', 'HYPERSPACE');
setupGameAction('btn-pause', 'PAUSE');
setupGameAction('btn-music', 'MUSIC');

touchToggle.addEventListener('change', (e) => { if(e.target.checked) touchInterface.classList.remove('hidden'); else touchInterface.classList.add('hidden'); });
editToggle.addEventListener('change', (e) => { isEditMode = e.target.checked; if(isEditMode) touchInterface.classList.add('edit-mode'); else touchInterface.classList.remove('edit-mode'); });

// --- MAIN LOOP ---
document.getElementById('init-audio-btn').addEventListener('click', () => {
    AudioEngine.init(); MusicManager.init(); MusicManager.playMenu();
    document.getElementById('audio-wall').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
    document.getElementById('crt-layer').classList.add('crt-active');
    if(/Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 1024) { touchToggle.checked = true; touchInterface.classList.remove('hidden'); }
    resize(); initStars('warp'); loop();
});

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', startGame);
document.getElementById('return-menu-btn').addEventListener('click', () => {
    gameState = 'MENU'; MusicManager.playMenu();
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('start-screen').classList.remove('hidden');
    initStars('warp');
});

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);

function initStars(mode) { stars = []; for(let i=0; i<150; i++) stars.push(new Star(mode)); }

function startGame() {
    gameState = 'PLAYING'; isPaused = false;
    // LOCK CONTROLS
    isEditMode = false; editToggle.checked = false; touchInterface.classList.remove('edit-mode');
    
    score = 0; lives = 3; level = 1; saucer = null; saucerTimer = 0;
    player = new Player(); projectiles = []; enemyProjectiles = []; asteroids = []; particles = [];
    
    MusicManager.playRandomGameTrack();
    
    for(let i=0; i<4; i++) {
        let x = Math.random()*canvas.width; let y = Math.random()*canvas.height;
        if(Math.hypot(x-player.x, y-player.y) > 200) asteroids.push(new Asteroid(x,y,3));
    }
    
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('score-hud').classList.remove('hidden');
    document.getElementById('lives-hud').classList.remove('hidden');
    document.getElementById('level-hud').classList.remove('hidden');
    initStars('static');
}

function loop() {
    requestAnimationFrame(loop);
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width, canvas.height);
    stars.forEach(s => { s.update(); s.draw(); });
    
    if (shakeDuration > 0) {
        ctx.save(); ctx.translate((Math.random()-0.5)*shakeMagnitude, (Math.random()-0.5)*shakeMagnitude); shakeDuration--;
    }

    if(gameState === 'PLAYING' && !isPaused) {
        if(player) { player.update(); player.draw(); }
        
        // SAUCER
        if(!saucer) {
            saucerTimer++;
            if(saucerTimer > (1000 - level*50)) { saucer = new Saucer(Math.random()<0.2?'small':'large'); saucerTimer=0; }
        } else {
            saucer.update(); saucer.draw();
            if(saucer.markedForDeletion) saucer = null;
            if(saucer && player.visible && Math.hypot(player.x-saucer.x, player.y-saucer.y) < 40) {
                player.die(); saucer.markedForDeletion = true; AudioEngine.stopSaucerSound();
            }
        }

        projectiles.forEach((p,i) => {
            p.update(); p.draw(); if(p.markedForDeletion) projectiles.splice(i,1);
        });

        enemyProjectiles.forEach((p,i) => {
            p.update(); p.draw(); if(p.markedForDeletion) enemyProjectiles.splice(i,1);
            if(player.visible && Math.hypot(p.x-player.x, p.y-player.y) < 15) {
                player.die(); enemyProjectiles.splice(i,1);
            }
        });

        asteroids.forEach((a,ai) => {
            a.update(); a.draw();
            
            // PROJECTILE vs ASTEROID
            projectiles.forEach((p,pi) => {
                if(Math.hypot(p.x-a.x, p.y-a.y) < a.radius) {
                    AudioEngine.explode(); score += (4-a.sizeClass)*100;
                    p.markedForDeletion = true; 
                    asteroids.splice(ai,1);
                    for(let k=0; k<5; k++) particles.push(new Particle(a.x, a.y, '#fff', 4));
                    if(a.sizeClass > 1) {
                        asteroids.push(new Asteroid(a.x, a.y, a.sizeClass-1));
                        asteroids.push(new Asteroid(a.x, a.y, a.sizeClass-1));
                    }
                }
            });
            
            // PROJECTILE vs SAUCER
            if(saucer) {
                 projectiles.forEach((p,pi) => {
                    if(Math.hypot(p.x-saucer.x, p.y-saucer.y) < saucer.radius) {
                        AudioEngine.explode(); AudioEngine.stopSaucerSound();
                        score += saucer.points;
                        floatingTexts.push(new FloatingText(saucer.x, saucer.y, saucer.points, '#ff4444'));
                        saucer.markedForDeletion = true; p.markedForDeletion = true;
                        for(let k=0; k<20; k++) particles.push(new Particle(saucer.x, saucer.y, '#ff4444', 6));
                    }
                 });
            }

            if(player.visible && Math.hypot(player.x-a.x, player.y-a.y) < player.radius + a.radius) {
                player.die();
            }
        });
        
        particles.forEach((p,i) => { p.update(); p.draw(); if(p.alpha<=0) particles.splice(i,1); });
        floatingTexts.forEach((f,i) => { f.update(); f.draw(); if(f.life<=0) floatingTexts.splice(i,1); });

        if(asteroids.length === 0 && !saucer) {
            level++; score += 1000;
            floatingTexts.push(new FloatingText(canvas.width/2, canvas.height/2 - 50, "SECTOR CLEARED", "#00ff00"));
            for(let i=0; i<3+level; i++) asteroids.push(new Asteroid(Math.random()*canvas.width, Math.random()*canvas.height, 3));
        }

        document.getElementById('score-val').innerText = score;
        document.getElementById('lives-val').innerText = lives;
        document.getElementById('level-val').innerText = level;
    }
    if (shakeDuration > 0) ctx.restore();
}

function gameOver() {
    gameState = 'GAMEOVER'; MusicManager.playOutro();
    document.getElementById('final-score').innerText = score;
    document.getElementById('game-over-screen').classList.remove('hidden');
}

window.addEventListener('keydown', e => {
    if(e.key === 'ArrowRight' && gameState === 'PLAYING' && player) player.shoot();
    if(e.key === 'Shift' && player) player.hyperspace();
    if(e.key === ' ') isPaused = !isPaused;
    if(keys.hasOwnProperty(e.key)) keys[e.key] = true;
});
window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });
</script>
</body>
</html>